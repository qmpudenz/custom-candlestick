<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Currency Candlestick</title>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/2.3.0/luxon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.2/echarts.min.js"></script>
</head>

<body>
  <div>
    <label for="startDate">Start Date:</label>
    <input type="date" id="startDate" name="startDate">
  
    <label for="endDate">End Date:</label>
    <input type="date" id="endDate" name="endDate">
  
    <button id="updateDateRange">Update Date Range</button>
  </div>
  
  
  <div id="menuBar"> <!-- Main application UI elements -->
    
  
    <select id="traderTable" class="selector"> <!-- Select options for time interval -->
      <option value="trader_M1">1 Minute</option>
      <option value="trader_M5">5 Minutes</option>
      <option value="trader_M15">15 Minutes</option>
      <option value="trader_H1" selected>1 Hour</option>
      <option value="trader_H4">4 Hours</option>
      <option value="trader_D">1 Day</option>
      <option value="trader_W">1 Week</option>
      <option value="trader_M">1 Month</option>
    </select>
    
    <select id="currency" class="selector"></select> <!-- Select options for currency pairs -->

    <select id="indicator-dropdown" class="selector"></select>

    <select id="indicatorFilter" class="selector"></select> <!-- Select options for indicators -->

    <button id="fetchData">Fetch Data</button> <!-- Button for fetching new data -->
  </div>
  
  <div id="chartWrapper">
   
    <div id="main"></div> <!-- Container for the chart -->
    <!-- Container for displaying the message when there is no data available -->
    <div id="noDataMessage">
      No line data available for this selection.
      <button id="closeMessage">X</button>
    </div>
  </div>
  
  <script>






// Register click event on the fetch button to request and draw new data
document.getElementById('fetchData').addEventListener('click', () => {
  const traderTable = document.getElementById('traderTable').value;
  const currency = document.getElementById('currency').value;
  const indicator = document.getElementById('indicator-dropdown').value;
  const filterIndicator = document.getElementById('indicatorFilter').value;
  fetchDataAndDrawChart(traderTable, currency, indicator, filterIndicator);
});


    // Close the no data message when escape key is pressed
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        document.getElementById('noDataMessage').style.display = 'none';
      }
    });

    // Close the no data message when the close button is clicked
    document.getElementById('closeMessage').addEventListener('click', () => {
      document.getElementById('noDataMessage').style.display = 'none';
    });


    // Declare and initialize global variables
    const { DateTime } = luxon;
    let chartData;
    let signalData;

    // Define a function to find the closest date in the candlestick data to a given date
    function findCandlestickForDate(targetDate, candlestickData) {
      let closestCandlestick = candlestickData[0];
      let closestTimeDifference = Math.abs(new Date(closestCandlestick.date) - targetDate);

      candlestickData.forEach(candlestick => {
        let currentCandlestickDate = new Date(candlestick.date);
        let currentTimeDifference = Math.abs(currentCandlestickDate - targetDate);

        if(currentTimeDifference < closestTimeDifference) {
          closestCandlestick = candlestick;
          closestTimeDifference = currentTimeDifference;
        }
      });

      return closestCandlestick;
    }


  // Function to fetch data from the API and draw the chart
  async function fetchDataAndDrawChart(traderTable, currency, indicator, filterIndicator) {
      // The function will show a loading message while the fetch operation is in progress
      myChart.showLoading({
        text: 'Loading...',
        textColor: '#000',
        maskColor: 'rgba(255, 255, 255, 0.8)',
        zlevel: 0
      });
    // Fetch start and end date from date inputs
    let startDate = document.getElementById('startDate').value;
    let endDate = document.getElementById('endDate').value;

    
      try {
        // Then it will fetch the candlestick and signals data, show a no data message if necessary
        const response = await fetch(`http://localhost:3002/data/${traderTable}/${currency}/${startDate}/${endDate}`);
        data = await response.json();
        const signalResponse = await fetch(`http://localhost:3002/nashsignals/${traderTable}/${currency}/${startDate}/${endDate}`);
        signalData = await signalResponse.json();

      


        if (signalData.length === 0) {
          // If there is no line data, show the message
          document.getElementById('noDataMessage').style.display = 'block';
        } else {
          // If there is line data, hide the message
          document.getElementById('noDataMessage').style.display = 'none';
        }

        // Then it will fetch the indicator data
        const indicatorResponse = await fetch('http://localhost:3002/ind_signal');
        const indicatorData = await indicatorResponse.json();
       

        // It converts the fetched candlestick data to the format used by the chart
        chartData = data.map(row => {
          const date_candle_started = row[0];
          const low = row[1];
          const open = row[2];
          const close = row[3];
          const high = row[4];
          return {date: date_candle_started, values: [open, close, low, high]};
        });

        const getIndicatorById = (id) => {
          const indicator = indicatorData.find(ind => ind.id === id);
          return indicator ? indicator.ind_signal : null;
        }
        document.getElementById("updateDateRange").addEventListener("click", updateDateRange);
        function updateDateRange() {
  const startDateInput = document.getElementById('startDate').value;
  const endDateInput = document.getElementById('endDate').value;

  if (startDateInput && endDateInput) {
  startDate = startDateInput;
  endDate = endDateInput;

    // Display success message or do something
    console.log(`Date range updated: ${startDate} to ${endDate}`);
  } else {
    // Handle error: both inputs should be filled
    console.log('Please fill both date inputs');
  }
  
  fetchDataAndDrawChart(traderTable, currency, indicator, filterIndicator);
  populateIndicatorDropdown(traderTable, currency, startDate, endDate);
  populateIndicatorFilter(traderTable, currency, startDate, endDate);
}

        // Then it creates the mark line data for the chart
        let markLineData = signalData.map(signal => {
          const [startDate, endDate, indicatorSource, signalType] = signal;
          const indicator = getIndicatorById(signalType);

          // Find the matching candlesticks for the start and end dates
          const startCandlestick = findCandlestickForDate(new Date(startDate), chartData);
          const endCandlestick = findCandlestickForDate(new Date(endDate), chartData);

          // Find the index of the start and end candlesticks
          const startIndex = chartData.findIndex(candlestick => candlestick.date === startCandlestick.date);
          const endIndex = chartData.findIndex(candlestick => candlestick.date === endCandlestick.date);

          let lineColor;
          switch (signalType) {
            case 'BUY':
            case 'BUY SOON':
              lineColor = 'green';
              break;
            case 'SELL':
            case 'SELL SOON':
              lineColor = 'red';
              break;
            default:
              lineColor = 'blue';
              break;
          }

          return [
            {
              name: 'start',
              symbol: 'circle',
              symbolSize: 7,
              coord: [startIndex, startCandlestick.values[1]],
              label: {
                  formatter: '',
                  position: 'start'
              },
              lineStyle: {
                  color: lineColor
              },
              tooltip: {
                formatter: function () {
                  const startFormattedDate = DateTime.fromISO(startDate).setZone('America/Chicago').toFormat('MM-dd-yyyy HH:mm');
                  const endFormattedDate = DateTime.fromISO(endDate).setZone('America/Chicago').toFormat('MM-dd-yyyy HH:mm');
                  return 'Signal Source: ' + indicatorSource + '<br />' + signalType + ': ' + startFormattedDate + " to " +  endFormattedDate;
                }
              }
            }, 
            {
              name: 'end',
              coord: [endIndex, endCandlestick.values[1]],
              symbol: 'circle',
              symbolSize: 7,
              tooltip: {
                formatter: function () {
                  const endFormattedDate = DateTime.fromISO(endDate).setZone('America/Chicago').toFormat('MM-dd-yyyy HH:mm');
                  return 'End: ' + endFormattedDate; 
                }
              }
            }
          ];
        });

        myChart.hideLoading();
        if (filterIndicator && filterIndicator !== 'all') {
    markLineData = markLineData.filter(data => data[0].tooltip.formatter().includes(filterIndicator));
  }
        // And finally it draws the chart
        drawChart(markLineData);
      } catch(error) {
        console.error('Error fetching data:', error);
        myChart.hideLoading();
      }
    }

    // Initialize the chart
    var myChart = echarts.init(document.getElementById('main'));
    window.addEventListener('resize', function() {
        myChart.resize();
    });

    // Function to draw the chart. The chart will display the fetched candlestick data and signal lines.
    function drawChart(markLineData) {
      const selectedIndicator = document.getElementById('indicator-dropdown').value;

      // Show all signals if 'All Signals' option is selected
      if (selectedIndicator !== 'all') {
        markLineData = markLineData.filter(data => data[0].tooltip.formatter().includes(selectedIndicator));  // filter the data
      }
      
      const option = {
        tooltip: {
        trigger: 'item',
        axisPointer: {
            type: 'cross'
        },
        formatter: function (params) {
        var date = DateTime.fromISO(chartData[params.dataIndex].date).setZone('America/Chicago');
        var formattedDate = date.toFormat('M-dd-yy H:mm');
        return formattedDate + '<br/>' +
            'Open: ' + params.value[1] + '<br/>' +
            'Close: ' + params.value[2] + '<br/>' +
            'Lowest: ' + params.value[3] + '<br/>' +
            'Highest: ' + params.value[4];
        }
        },

        dataZoom: [{
          type: 'inside',
          start: 90, // Display last 10% of data
          end: 100
        }],
        xAxis: {
          type: 'category',
          data: chartData.map(candlestick => {
            return DateTime.fromISO(candlestick.date).setZone('America/Chicago').toFormat('M-dd-yy H:mm');
          }),
        },

        yAxis: {
          scale: true
        },
        series: [
          {
            type: 'candlestick',
            data: chartData.map(candlestick => candlestick.values),
            itemStyle: {
              color: '#009129',
              color0: '#d50000',
              borderColor: '#009129',
              borderColor0: '#d50000'
            },

            markLine: {
              showSymbol: true,
              symbol: 'circle', // specify the shape of symbol, optional
              symbolSize: 8, // increase the symbol size
              connectNulls: true,
              data: markLineData,
              lineStyle: {
              width: 4, // you may want to increase line width as well
              color: '#0000FF',
              type: 'solid'
            }
            }
          },
        ]
      };
      myChart.setOption(option);
    }

    // Function to fetch the list of available currency pairs
    async function fetchIndicators(successCallback, errorCallback) {
      try {
        const response = await fetch('http://localhost:3002/currency');
        const data = await response.json();
        successCallback(data);
      } catch(error) {
        errorCallback(error);
      }
    }
 

 




    async function populateIndicatorDropdown(traderTable, currency, startDate, endDate) {
  const signalResponse = await fetch(`http://localhost:3002/nashsignals/${traderTable}/${currency}/${startDate}/${endDate}`);
  const signalData = await signalResponse.json();
  
  // Add logging
  console.log('Signal Data for Indicator Dropdown:', signalData);

  // Populate 'indicator-dropdown'
  const uniqueSignalSources = [...new Set(signalData.map(item => item[2]))];

  // Add logging
  console.log('Unique Signal Sources:', uniqueSignalSources);

  const dropdown = document.getElementById('indicator-dropdown');
  if (uniqueSignalSources.length > 0) {
    dropdown.innerHTML = `<option value="all">All Signals</option>` + uniqueSignalSources.map(source => `<option value="${source}">${source}</option>`).join("");
  } else {
    dropdown.innerHTML = '<option value="">No line data</option>';
  }
}

// Function to populate 'indicatorFilter'
async function populateIndicatorFilter(traderTable, currency, startDate, endDate) {
  const signalResponse = await fetch(`http://localhost:3002/nashsignals/${traderTable}/${currency}/${startDate}/${endDate}`);
  const signalData = await signalResponse.json();
  
  // Add logging
  console.log('Signal Data for Indicator Filter:', signalData);

  // Populate 'indicatorFilter'
  const uniqueIndicators = [...new Set(signalData.map(item => item[3]))];  // assuming item[3] is the Buy/Sell indicator
  
  // Add logging
  console.log('Unique Indicators:', uniqueIndicators);

  const indicatorFilter = document.getElementById('indicatorFilter');
  if (uniqueIndicators.length > 0) {
    indicatorFilter.innerHTML = '<option value="all">All</option>' + uniqueIndicators.map(indicator => `<option value="${indicator}">${indicator}</option>`).join("");
  } else {
    indicatorFilter.innerHTML = '<option value="all">None</option>';
  }
}

// Event listener for 'currency' change
document.getElementById('currency').addEventListener('change', async () => {
  const traderTable = document.getElementById('traderTable').value;
  const currency = document.getElementById('currency').value;
  const startDate = document.getElementById('startDate').value;
  const endDate = document.getElementById('endDate').value;
  populateIndicatorDropdown(traderTable, currency, startDate, endDate);
  populateIndicatorFilter(traderTable, currency, startDate, endDate);
});

// This function will fetch new data based on the selected source and populate the 'indicatorFilter' dropdown
async function populateIndicatorFilterBasedOnSource(traderTable, currency, startDate, endDate, source) {
  const signalResponse = await fetch(`http://localhost:3002/nashsignals/${traderTable}/${currency}/${startDate}/${endDate}`);
  const signalData = await signalResponse.json();

  let filteredSignalData;

  // If source is "All Signals", include all signal data. Otherwise, filter the data based on the selected source.
  if (source === 'all') {
    filteredSignalData = signalData;
  } else {
    filteredSignalData = signalData.filter(item => item[2] === source); // assuming item[2] is the source
  }

  const uniqueIndicators = [...new Set(filteredSignalData.map(item => item[3]))]; // assuming item[3] is the Buy/Sell indicator
  const indicatorFilter = document.getElementById('indicatorFilter');
  if (uniqueIndicators.length > 0) {
    indicatorFilter.innerHTML = '<option value="all">All</option>' + uniqueIndicators.map(indicator => `<option value="${indicator}">${indicator}</option>`).join("");
  } else {
    indicatorFilter.innerHTML = '<option value="all">All</option>';
  }
}


// Event listener for 'indicator-dropdown' change
document.getElementById('indicator-dropdown').addEventListener('change', async () => {
  const traderTable = document.getElementById('traderTable').value;
  const currency = document.getElementById('currency').value;
  const source = document.getElementById('indicator-dropdown').value;
  const startDate = document.getElementById('startDate').value;
  const endDate = document.getElementById('endDate').value;
  // Call the new function to populate 'indicatorFilter' based on the selected source
  populateIndicatorFilterBasedOnSource(traderTable, currency, startDate, endDate, source);
});


   

// Fetch the available currency pairs and populate the currency select element when the page loads
window.onload = () => {
  document.getElementById('startDate').value = '2023-04-01';
  document.getElementById('endDate').value = '2023-05-23';
  let startDate = document.getElementById('startDate').value;
  let endDate = document.getElementById('endDate').value;
  console.log(startDate)

  // Fetch initial data and draw the chart
  const traderTable = document.getElementById('traderTable').value;
  const currency = document.getElementById('currency').value;

  fetchIndicators(
    async (currencyData) => {
      const currencySelect = document.getElementById('currency');
      currencySelect.innerHTML = '';
      let firstOption = null;
      currencyData.forEach(([id, currency_name]) => {
        if (currency_name.includes('_')) {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = currency_name.replace('_', '/');
          currencySelect.appendChild(option);
          if (!firstOption) {
            firstOption = option;
          }
        }
      });

      if (firstOption) {
        firstOption.selected = true;
        const traderTable = 'trader_H1'; // replace 'trader_H1' with your initial traderTable value
        const currency = document.getElementById('currency').value;
        const source = document.getElementById('indicator-dropdown').value;
  
        // Fetch initial data and draw the chart
        fetchDataAndDrawChart(traderTable, currency, 'all', 'all');
        populateIndicatorDropdown(traderTable, currency, startDate, endDate);
          populateIndicatorFilter(traderTable, currency, startDate, endDate);
          
        const signalResponse = await fetch(`http://localhost:3002/nashsignals/${traderTable}/${currency}/${startDate}/${endDate}`);
        const signalData = await signalResponse.json();
        if (signalData && signalData.length > 0) {
          // Call event listener code here
        }
      } else {
        console.log('No valid currency options found');
      }
    },
    (error) => {
      console.error('An error occurred:', error);
    }
  );
};


  </script>
</body>
</html>
